#!/bin/bash

. ns import "sv_*"

if [[ -z "$sv_sep" ]]; then
    sv_sep=,
fi

sep="$sv_sep"
file="$sv_file"
rowno="$sv_row"

dir="${file%/*}"

if [[ -z "$rowno" ]]; then
    echo "sv save row failed due to no previously loaded row found, run the load command first"
    exit 1
fi

if [[ ! -f "$file" ]]; then
    echo "sv save failed. '${file}' is not a regular file" >&2
    exit 1
fi

header=
wcl=$(cat "$file" | wc -l)
exists=0
if [[ $wcl -gt 1 ]]; then
    header=$(cat "$file" | head -1)
    exists=1
fi
# echo "$header"
row=
saveIFS="$IFS"
IFS="$sep"
for col in $header
do
    name=$(set | grep "^sv_${col}=" | cut -d '=' -f1 | head -1)

    val="${!name}"

    svns_rc="$val"
    svns_nl_repl=1
    . ns run sv-sep-sub-rc
    # echo "$val" "Vs" "$svns_rc_subst"
    val="$svns_rc_subst"

    if [[ -z "$row" ]]; then
        row="$val"
    else
        row="${row}${sep}${val}"
    fi
done
IFS="$saveIFS"

lineno=$((rowno+1))
# echo "$lineno"
# echo "$row"

# TODO: USE ALTERNATIVE TO IN-PLACE SED LINE REPLACE LINE
# CURRENT IMPLEMENTATION IS BROKEN BECAUSE  {lineno} CANNOT ALWAYS BE ROW+1
#     TODO #1 - SHOULD FIND THE REAL {lineno}, ACCOUNTING FOR PREVIOUS ROWS THAT SPAN MULTIPLE
#               LINES (FOR QUOTED COLUMNS CONTAINING NEWLINES)
#     TODO #2 - FIND ROW {lineno} and {linespan} BEFORE THE UPDATE TO DELETE ANY ROWS EXISTING
#               AFTER {lineno}
sed -i "${lineno} c${row}" "$sv_file"


. ns export "sv_*"
